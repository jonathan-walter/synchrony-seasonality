---
title: "Seasonality in Spatial Synchrony"
author: "Jonathan Walter"
date: "9/12/2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

setwd("~/GitHub/synchrony-seasonality")
```

## Overview

This R Markdown document organizes for completeness and replicability a series of simulations examining how seasonality in the degree of environmental spatial synchrony affects population spatial synchrony, extinction risk, and detection and attribution of drivers of population spatial synchrony.

# Effects of seasonality on synchrony, linear population dynamics

First, compare analytical solution to an equivalent simulation model to confirm it works

```{r linear.compare, echo=FALSE, cache=TRUE}
library(parallel)
library(lhs)
source("~/GitHub/synchrony-seasonality/Fn_popSynchByStage_linear_20210315.R")

# nn<-200
# 
# set.seed(666)
# hypercube<-optimumLHS(n=nn, k=6)

tmax=10000
a1=0.1
a2=0.4
rho.b=0.5
rho.w=0.8
sd.b=0.5
sd.w=sd.b
nlocs=2

linear.test<-popSynchByStage.linear(a1, a2, rho.b, rho.w, sd.b, sd.w, tmax, nlocs, ret.eb=TRUE, ret.ew=TRUE)
  
analytical.solution<-function(a2, eb, ew){
  
  ax = (1 - a2)
  var.b = var(eb[1,])
  var.w = var(ew[1,])
  eb1 = eb[1,]
  eb2 = eb[2,]
  ew1 = ew[1,]
  ew2 = ew[2,]
  
  return((ax^2*cov(eb1,eb2) + ax*cov(eb1,ew2) + ax*cov(ew1,eb2) + cov(ew1,ew2))/(ax^2*var.b + var.w))
}

cor(linear.test$Nt[1,-c(1:100)], linear.test$Nt[2,-c(1:100)])

analytical.solution(a2, linear.test$eb[,-c(1:100)], linear.test$ew[,-c(1:100)])


```

Next, independently and simultaneously vary environmental correlation while holding other factors constant.
Still using the analytical solution.
```{r analytical.surface, echo=FALSE, cache=TRUE}

a2=0.5
rho.b=seq(0,1,by=0.01)
rho.w=rho.b
sd.b=0.5
sd.w=sd.b
nlocs=2

analytical.solution2<-function(a2, rho.b, rho.w, sd.b, sd.w){ #assumes that cov(eb1,ew2) = 0 & cov(ew1,eb2) = 0

  ax = (1 - a2)
  var.b = sd.b^2
  var.w = sd.w^2
  
  return((ax^2*(rho.b*var.b) + (rho.w*var.w))/(ax^2*var.b + var.w))
}
  
varrhos.analytical1<-matrix(NA, length(rho.b), length(rho.w))
for(ii in 1:length(rho.b)){
  for(jj in 1:length(rho.w)){
    varrhos.analytical1[ii,jj]<-analytical.solution2(a2, rho.b[ii], rho.w[jj], sd.b, sd.w)
  }
}

#vary a2 while holding spatial synchrony and driver variance constant
a2seq<-seq(0,1,by=0.05)

a2_v1.analytical<-rep(NA, length(a2seq))
a2_v2.analytical<-rep(NA, length(a2seq))
a2_v3.analytical<-rep(NA, length(a2seq))

for(ii in 1:length(a2seq)){
  
  a2_v1.analytical[ii]<-analytical.solution2(a2seq[ii], rho.b=0.7, rho.w=0.3, sd.b, sd.w)
  a2_v2.analytical[ii]<-analytical.solution2(a2seq[ii], rho.b=0.3, rho.w=0.7, sd.b, sd.w)
  a2_v3.analytical[ii]<-analytical.solution2(a2seq[ii], rho.b=0.5, rho.w=0.5, sd.b, sd.w)
  
}


## change driver variances while pinning synchrony and a2 <------------------------------------------------------------
sd.bseq<-seq(0,1,0.05)
sd.wseq<-seq(0,1,0.05)

sd.b_v1.analytical<-rep(NA, length(sd.bseq))
sd.w_v1.analytical<-rep(NA, length(sd.wseq))

sd.b_v2.analytical<-rep(NA, length(sd.bseq))
sd.w_v2.analytical<-rep(NA, length(sd.wseq))

sd.b_v3.analytical<-rep(NA, length(sd.bseq))
sd.w_v3.analytical<-rep(NA, length(sd.wseq))

for(ii in 1:length(sd.bseq)){
  
  sd.b_v1.analytical[ii]<-analytical.solution2(a2, rho.b=0.3, rho.w=0.7, sd.b=sd.bseq[ii], sd.w=sd.w)
  sd.w_v1.analytical[ii]<-analytical.solution2(a2, rho.b=0.3, rho.w=0.7, sd.b=sd.b, sd.w=sd.wseq[ii])
  
  sd.b_v2.analytical[ii]<-analytical.solution2(a2, rho.b=0.7, rho.w=0.3, sd.b=sd.bseq[ii], sd.w=sd.w)
  sd.w_v2.analytical[ii]<-analytical.solution2(a2, rho.b=0.7, rho.w=0.3, sd.b=sd.b, sd.w=sd.wseq[ii])
  
  sd.b_v3.analytical[ii]<-analytical.solution2(a2, rho.b=0.5, rho.w=0.5, sd.b=sd.bseq[ii], sd.w=sd.w)
  sd.w_v3.analytical[ii]<-analytical.solution2(a2, rho.b=0.5, rho.w=0.5, sd.b=sd.b, sd.w=sd.wseq[ii])
  
}

pal<-colorRampPalette(colors=c("red","white","blue"))


#Make nice figure!
png("~/GitHub/synchrony-seasonality/fig1_analytical.png", units="in", res=300, width=3, height=8)

par(mfrow=c(3,1), mar=c(3.5,3.5,1.5,1), mgp=c(1.7,0.5,0))
#varying synchrony
image(rho.b, rho.w, varrhos.analytical1, zlim=c(-1,1), col=pal(50),
      xlab=expression(rho[b]), ylab=expression(rho[w]))
contour(rho.b, rho.w, varrhos.analytical1, add=T)
mtext(expression(paste(a[2]," = 0.5, var(",epsilon[b],") = var(",epsilon[w],") = 0.25")), cex=0.6)

#varying a2
plot(a2seq, a2_v1.analytical, type="l", ylim=c(0,1), xlab=expression(a[2]), ylab="Population synchrony")
lines(a2seq, a2_v2.analytical, lty=2)
lines(a2seq, a2_v3.analytical, lty=3)
mtext(expression(paste("var(",epsilon[b],") = var(",epsilon[w],") = 0.25")), cex=0.6)
legend("topright", legend=c(expression(paste(rho[b]," = 0.3, ",rho[w]," = 0.7")), 
                            expression(paste(rho[b]," =  ",rho[w]," = 0.5")), 
                            expression(paste(rho[b]," = 0.7, ",rho[w]," = 0.3"))), 
       lty=c(1,3,2), bty="n", cex=0.9)

#varying driver variances
plot(sd.bseq, sd.b_v1.analytical, type="l", ylim=c(0,1), xlab="Driver variance",
     ylab="Population synchrony")
lines(sd.wseq, sd.w_v1.analytical, lty=1, col="red")

lines(sd.bseq, sd.b_v2.analytical, lty=2)
lines(sd.wseq, sd.w_v2.analytical, lty=2, col="red")

lines(sd.bseq, sd.b_v3.analytical, lty=1)
lines(sd.wseq, sd.w_v3.analytical, lty=3, col="red")
mtext(expression(paste(a[2]," = 0.5")), cex=0.6)
legend("top", ncol=2, legend=c(expression(paste("changing var(",epsilon[b],")"))
                               , expression(paste("changing var(",epsilon[w],")"))), 
       lty=1, col=c("black","red"), bty="n", cex=0.9)
legend("bottom", ncol=2, legend=c(expression(paste(rho[b]," = 0.3, ",rho[w]," = 0.7")), 
                            expression(paste(rho[b]," = ",rho[w]," = 0.5")), 
                            expression(paste(rho[b]," = 0.7, ",rho[w]," = 0.3"))), 
       lty=c(1,3,2), bty="n", cex=0.9)

dev.off()

```


# Effects of seasonality on synchrony and extinction, nonlinear dynamics 

This section relies on simulation.
First, examine sensitivity of model outcomes (spatial synchrony) to parameter values.
Parameter space is sampled using latin hypercube. 

```{r nlin.sensitivity, echo=FALSE, cache=TRUE}
rm(list=ls())
library(parallel)
library(lhs)
library(viridis)
source("~/GitHub/synchrony-seasonality/Fn_synchsim_mainmodel_eK.R")
source("~/GitHub/synchrony-seasonality/Fn_synchsim_altmodel_sameEnvironment_eK.R")
source("~/GitHub/synchrony-seasonality/Fn_synchsim_altmodel_noOverwintering_eK.R")
nn<-250

# set.seed(667)
# hypercube<-optimumLHS(n=nn, k=8)
# 
# write.csv(hypercube, "~/GitHub/synchrony-seasonality/params_hypercube_n250_k8.csv", row.names=FALSE)

hypercube<-as.matrix(read.csv("~/GitHub/synchrony-seasonality/params_hypercube_n250_k8.csv"))

r=qunif(hypercube[,1],0.1,2)
Kb=qunif(hypercube[,6],5,10)
Kw=qunif(hypercube[,7],5,10)
rho.b=hypercube[,2]
rho.w=hypercube[,3]
sd.b=qunif(hypercube[,4],1/3,3)
sd.w=qunif(hypercube[,5],1/3,3)
Db=qunif(hypercube[,8],0,0.3)#runif(nn,0,0.4)
Dw=0
tmax=1100
burn=100
nlocs=2

ncores=detectCores()-4

cl<-makeCluster(ncores)
sens.main<-mcmapply(synchsim_main, r=r, Kb=Kb, Kw=Kw, rho.b=rho.b, rho.w=rho.w,
                       sd.b=sd.b, sd.w=sd.w, Db=Db, Dw=Dw, tmax=tmax, nlocs=nlocs, SIMPLIFY = F)
sens.same<-mcmapply(synchsim_sameEnv,r=r,Kb=Kb, Kw=Kw, rho.b=rho.b,
                        sd.b=sd.b,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)
sens.noow<-mcmapply(synchsim_noOverwint,r=r,K=Kb,rho.b=rho.b,rho.w=rho.w,
                        sd.b=sd.b,sd.w=sd.w,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)
stopCluster(cl)

getNtcor<-function(inlist){ #extract synchrony in Nt
  out<-rep(NA, length(inlist))
  for(ii in 1:length(inlist)){
    tmp<-log(inlist[[ii]]$Nt[,-c(1:burn)])
    out[ii]<-cor(t(tmp))[2,1]
  }
  return(out)
}

  
sampres.main<-data.frame(rhoN=getNtcor(sens.main), #scale predictors to standardize effect sizes
                       r=scale(r), Kb=scale(Kb), Kw=scale(Kw),rho.b=scale(rho.b),sd.b=scale(sd.b),
                       sd.w=scale(sd.w),rho.w=scale(rho.w),Db=scale(Db))

sampres.same<-data.frame(rhoN=getNtcor(sens.same), #scale predictors to standardize effect sizes
                       r=scale(r), Kb=scale(Kb), Kw=scale(Kw),rho.b=scale(rho.b),sd.b=scale(sd.b),
                       Db=scale(Db))

sampres.noow<-data.frame(rhoN=getNtcor(sens.noow), #scale predictors to standardize effect sizes
                       r=scale(r), Kb=scale(Kb), rho.b=scale(rho.b),sd.b=scale(sd.b),
                       sd.w=scale(sd.w),rho.w=scale(rho.w),Db=scale(Db))

lm.samp.main<-lm(rhoN~r+Kb+Kw+rho.b+rho.w+sd.b+sd.w+sd.b*rho.b+sd.w*rho.w+rho.b*rho.w+Kw*Kb+Db, data=sampres.main, na.action=na.exclude)
summary(lm.samp.main)

lm.samp.same<-lm(rhoN~r+Kb+Kw+rho.b+sd.b+sd.b*rho.b+Kw*Kb+Db, data=sampres.same, na.action=na.exclude)
summary(lm.samp.same)

lm.samp.noow<-lm(rhoN~r+Kb+rho.b+rho.w+sd.b+sd.w+sd.b*rho.b+sd.w*rho.w+rho.b*rho.w+Db, 
                 data=sampres.noow, na.action=na.exclude)
summary(lm.samp.noow)




# png("fig_parameffects_main_eK.png", units="in", res=300, 
#      width=6.5, height=3.25)
# par(mar=c(6,5,1,1))
# barplot(lm.samp.main$coefficients[-1], las=2, ylab = "Coefficient")
# #text(seq(from=0.6,by=1.2,length.out=length(lm.samp.rhoN$coefficients)-1),lm.samp.rhoN$coefficients[-1],paste0("p=",round(modsumm.add$coefficients[-1,4],2)),pos=3,offset=0.5)
# dev.off()
# 
# png("fig_parameffects_same_eK.png", units="in", res=300, 
#      width=6.5, height=3.25)
# par(mar=c(6,5,1,1))
# barplot(lm.samp.same$coefficients[-1], las=2, ylab = "Coefficient")
# #text(seq(from=0.6,by=1.2,length.out=length(lm.samp.rhoN$coefficients)-1),lm.samp.rhoN$coefficients[-1],paste0("p=",round(modsumm.add$coefficients[-1,4],2)),pos=3,offset=0.5)
# dev.off()
# 
# png("fig_parameffects_noow_eK.png", units="in", res=300, 
#      width=6.5, height=3.25)
# par(mar=c(6,5,1,1))
# barplot(lm.samp.noow$coefficients[-1], las=2, ylab = "Coefficient")
# #text(seq(from=0.6,by=1.2,length.out=length(lm.samp.rhoN$coefficients)-1),lm.samp.rhoN$coefficients[-1],paste0("p=",round(modsumm.add$coefficients[-1,4],2)),pos=3,offset=0.5)
# dev.off()


# save(modsumm.add, file="modsumm_main.RData")
plotmat<-rbind(lm.samp.main$coefficients[-1],
               c(lm.samp.same$coefficients[-1][1:4],NA,lm.samp.same$coefficients[-1][5],NA,
                 lm.samp.same$coefficients[-1][6:7],NA,NA,lm.samp.same$coefficients[-1][8]),
               c(lm.samp.noow$coefficients[-1][1:2],NA,lm.samp.noow$coefficients[-1][3:10],NA))

semat<-rbind(summary(lm.samp.main)$coefficients[-1,2],
             c(summary(lm.samp.main)$coefficients[-1,2][1:4],NA,
               summary(lm.samp.main)$coefficients[-1,2][5],NA,
               summary(lm.samp.main)$coefficients[-1,2][6:7],NA,NA,
             summary(lm.samp.main)$coefficients[-1,2][8]),
             c(summary(lm.samp.main)$coefficients[-1,2][1:2],NA,
               summary(lm.samp.main)$coefficients[-1,2][3:10],NA)
)


plotnames<-c("r",
             expression(K[B]),
             expression(K[W]),
             expression(rho[B]),
             expression(rho[W]),
             expression(sigma[B]),
             expression(sigma[W]),
             "d",
             expression(paste(rho[B], sigma[B])),
             expression(paste(rho[W], sigma[W])),
             expression(paste(rho[B], rho[W])),
             expression(paste(K[B], K[W]))
             )
# save(modsumm.add, file="modsumm_main.RData")

png("figA4_simsens_eK.png", units="in", res=300, width=6.5, height=3.5)
par(mar=c(4,4,1,0.5))
b<-barplot(plotmat, las=2, ylab = "Effect size", beside=TRUE, names.arg=plotnames,
           ylim=c(-0.2,0.3),col=c("grey25","grey50","grey75"))
#abline(h=0)
text(x=c(11.5,18.5,26.5,38.5,42.5,47.5),y=0,labels="na",cex=0.5,adj=c(0.5,0))
arrows(x0=c(b), y0=c(plotmat)+1*c(semat), x1=c(b), y1=c(plotmat)-1*c(semat), length=0.02, 
       angle=90, code=3)
legend("topright",bty="n",pch=15,col=c("grey25","grey50","grey75"),
       legend=c("Main model","Same environment","No overwintering"))
dev.off()


```
Now, with noises on r during breeding season and w during overwintering

```{r nlin.sensitivity2, echo=FALSE, cache=TRUE}
rm(list=ls())
library(parallel)
library(lhs)
library(viridis)
source("~/GitHub/synchrony-seasonality/Fn_synchsim_mainmodel_ereK.R")
source("~/GitHub/synchrony-seasonality/Fn_synchsim_altmodel_sameEnvironment_ereK.R")
source("~/GitHub/synchrony-seasonality/Fn_synchsim_altmodel_noOverwintering_ereK.R")
nn<-250

# set.seed(667)
# hypercube<-optimumLHS(n=nn, k=7)
# 
#write.csv(hypercube, "~/GitHub/synchrony-seasonality/params_hypercube_n250_k7.csv", row.names=FALSE)

hypercube<-as.matrix(read.csv("~/GitHub/synchrony-seasonality/params_hypercube_n250_k8.csv"))

r=qunif(hypercube[,1],0.1,2)
Kb=qunif(hypercube[,6],5,10)
Kw=qunif(hypercube[,7],5,10)
rho.b=hypercube[,2]
rho.w=hypercube[,3]
sd.b=qunif(hypercube[,4],1/3,3)
sd.w=qunif(hypercube[,5],1/3,3)
Db=qunif(hypercube[,8],0,0.3)#runif(nn,0,0.4)
Dw=0
tmax=1100
burn=100
nlocs=2

ncores=detectCores()-4

cl<-makeCluster(ncores)
sens.main<-mcmapply(synchsim_main, r=r, Kb=Kb, Kw=Kw, rho.b=rho.b, rho.w=rho.w,
                       sd.b=sd.b, sd.w=sd.w, Db=Db, Dw=Dw, tmax=tmax, nlocs=nlocs, SIMPLIFY = F)
sens.same<-mcmapply(synchsim_sameEnv,r=r,Kb=Kb, Kw=Kw, rho.b=rho.b,
                        sd.b=sd.b,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)
sens.noow<-mcmapply(synchsim_noOverwint,r=r,K=Kb,rho.b=rho.b,rho.w=rho.w,
                        sd.b=sd.b,sd.w=sd.w,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)
stopCluster(cl)

getNtcor<-function(inlist){ #extract synchrony in Nt
  out<-rep(NA, length(inlist))
  for(ii in 1:length(inlist)){
    tmp<-log(inlist[[ii]]$Nt[,-c(1:burn)])
    out[ii]<-cor(t(tmp))[2,1]
  }
  return(out)
}

  
sampres.main<-data.frame(rhoN=getNtcor(sens.main), #scale predictors to standardize effect sizes
                       r=scale(r), Kb=scale(Kb), Kw=scale(Kw),rho.b=scale(rho.b),sd.b=scale(sd.b),
                       sd.w=scale(sd.w),rho.w=scale(rho.w),Db=scale(Db))

sampres.same<-data.frame(rhoN=getNtcor(sens.same), #scale predictors to standardize effect sizes
                       r=scale(r), Kb=scale(Kb), Kw=scale(Kw),rho.b=scale(rho.b),sd.b=scale(sd.b),
                       Db=scale(Db))

sampres.noow<-data.frame(rhoN=getNtcor(sens.noow), #scale predictors to standardize effect sizes
                       r=scale(r), Kb=scale(Kb), rho.b=scale(rho.b),sd.b=scale(sd.b),
                       sd.w=scale(sd.w),rho.w=scale(rho.w),Db=scale(Db))

lm.samp.main<-lm(rhoN~r+Kb+Kw+rho.b+rho.w+sd.b+sd.w+sd.b*rho.b+sd.w*rho.w+rho.b*rho.w+Kw*Kb+Db, data=sampres.main, na.action=na.exclude)
summary(lm.samp.main)

lm.samp.same<-lm(rhoN~r+Kb+Kw+rho.b+sd.b+sd.b*rho.b+Kw*Kb+Db, data=sampres.same, na.action=na.exclude)
summary(lm.samp.same)

lm.samp.noow<-lm(rhoN~r+Kb+rho.b+rho.w+sd.b+sd.w+sd.b*rho.b+sd.w*rho.w+rho.b*rho.w+Db, data=sampres.noow, na.action=na.exclude)
summary(lm.samp.noow)



# 
# png("fig_parameffects_main_ereK.png", units="in", res=300, 
#      width=6.5, height=3.25)
# par(mar=c(6,5,1,1))
# barplot(lm.samp.main$coefficients[-1], las=2, ylab = "Coefficient")
# #text(seq(from=0.6,by=1.2,length.out=length(lm.samp.rhoN$coefficients)-1),lm.samp.rhoN$coefficients[-1],paste0("p=",round(modsumm.add$coefficients[-1,4],2)),pos=3,offset=0.5)
# dev.off()
# 
# png("fig_parameffects_same_ereK.png", units="in", res=300, 
#      width=6.5, height=3.25)
# par(mar=c(6,5,1,1))
# barplot(lm.samp.same$coefficients[-1], las=2, ylab = "Coefficient")
# #text(seq(from=0.6,by=1.2,length.out=length(lm.samp.rhoN$coefficients)-1),lm.samp.rhoN$coefficients[-1],paste0("p=",round(modsumm.add$coefficients[-1,4],2)),pos=3,offset=0.5)
# dev.off()
# 
# png("fig_parameffects_noow_ereK.png", units="in", res=300, 
#      width=6.5, height=3.25)
# par(mar=c(6,5,1,1))
# barplot(lm.samp.noow$coefficients[-1], las=2, ylab = "Coefficient")
# #text(seq(from=0.6,by=1.2,length.out=length(lm.samp.rhoN$coefficients)-1),lm.samp.rhoN$coefficients[-1],paste0("p=",round(modsumm.add$coefficients[-1,4],2)),pos=3,offset=0.5)
# dev.off()


# save(modsumm.add, file="modsumm_main.RData")

plotmat<-rbind(lm.samp.main$coefficients[-1],
               c(lm.samp.same$coefficients[-1][1:4],NA,lm.samp.same$coefficients[-1][5],NA,
                 lm.samp.same$coefficients[-1][6:7],NA,NA,lm.samp.same$coefficients[-1][8]),
               c(lm.samp.noow$coefficients[-1][1:2],NA,lm.samp.noow$coefficients[-1][3:10],NA))

semat<-rbind(summary(lm.samp.main)$coefficients[-1,2],
             c(summary(lm.samp.main)$coefficients[-1,2][1:4],NA,
               summary(lm.samp.main)$coefficients[-1,2][5],NA,
               summary(lm.samp.main)$coefficients[-1,2][6:7],NA,NA,
             summary(lm.samp.main)$coefficients[-1,2][8]),
             c(summary(lm.samp.main)$coefficients[-1,2][1:2],NA,
               summary(lm.samp.main)$coefficients[-1,2][3:10],NA)
)


plotnames<-c("r",
             expression(K[B]),
             expression(K[W]),
             expression(rho[B]),
             expression(rho[W]),
             expression(sigma[B]),
             expression(sigma[W]),
             "d",
             expression(paste(rho[B], sigma[B])),
             expression(paste(rho[W], sigma[W])),
             expression(paste(rho[B], rho[W])),
             expression(paste(K[B], K[W]))
             )
# save(modsumm.add, file="modsumm_main.RData")

png("figA1_simsens_ereK.png", units="in", res=300, width=6.5, height=3.5)
par(mar=c(4,4,1,0.5))
b<-barplot(plotmat, las=2, ylab = "Effect size", beside=TRUE, names.arg=plotnames,
           ylim=c(-0.7,0.8),col=c("grey25","grey50","grey75"))
#abline(h=0)
text(x=c(11.5,18.5,26.5,38.5,42.5,47.5),y=0,labels="na",cex=0.5,adj=c(0.5,0))
arrows(x0=c(b), y0=c(plotmat)+1*c(semat), x1=c(b), y1=c(plotmat)-1*c(semat), length=0.02, 
       angle=90, code=3)
legend("topright",bty="n",pch=15,col=c("grey25","grey50","grey75"),
       legend=c("Main model","Same environment","No overwintering"))
dev.off()

```
Now, with noises affecting N(t) additively.
```{r nlin.sensitivity3, echo=FALSE, cache=TRUE}
rm(list=ls())
library(parallel)
library(lhs)
library(viridis)
source("~/GitHub/synchrony-seasonality/Fn_synchsim_mainmodel_eN.R")
source("~/GitHub/synchrony-seasonality/Fn_synchsim_altmodel_sameEnvironment_eN.R")
source("~/GitHub/synchrony-seasonality/Fn_synchsim_altmodel_noOverwintering_eN.R")
nn<-250

# set.seed(667)
# hypercube<-optimumLHS(n=nn, k=7)
# 
#write.csv(hypercube, "~/GitHub/synchrony-seasonality/params_hypercube_n250_k7.csv", row.names=FALSE)

hypercube<-as.matrix(read.csv("~/GitHub/synchrony-seasonality/params_hypercube_n250_k8.csv"))

r=qunif(hypercube[,1],0.1,2)
Kb=qunif(hypercube[,6],5,10)
Kw=qunif(hypercube[,7],5,10)
rho.b=hypercube[,2]
rho.w=hypercube[,3]
sd.b=qunif(hypercube[,4],1/3,3)
sd.w=qunif(hypercube[,5],1/3,3)
Db=qunif(hypercube[,8],0,0.3)#runif(nn,0,0.4)
Dw=0
tmax=1100
burn=100
nlocs=2

ncores=detectCores()-4

cl<-makeCluster(ncores)
sens.main<-mcmapply(synchsim_main, r=r, Kb=Kb, Kw=Kw, rho.b=rho.b, rho.w=rho.w,
                       sd.b=sd.b, sd.w=sd.w, Db=Db, Dw=Dw, tmax=tmax, nlocs=nlocs, SIMPLIFY = F)
sens.same<-mcmapply(synchsim_sameEnv,r=r,Kb=Kb, Kw=Kw, rho.b=rho.b,
                        sd.b=sd.b,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)
sens.noow<-mcmapply(synchsim_noOverwint,r=r,K=Kb,rho.b=rho.b,rho.w=rho.w,
                        sd.b=sd.b,sd.w=sd.w,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)
stopCluster(cl)

getNtcor<-function(inlist){ #extract synchrony in Nt
  out<-rep(NA, length(inlist))
  for(ii in 1:length(inlist)){
    tmp<-log(inlist[[ii]]$Nt[,-c(1:burn)])
    out[ii]<-cor(t(tmp))[2,1]
  }
  return(out)
}

  
sampres.main<-data.frame(rhoN=getNtcor(sens.main), #scale predictors to standardize effect sizes
                       r=scale(r), Kb=scale(Kb), Kw=scale(Kw),rho.b=scale(rho.b),sd.b=scale(sd.b),
                       sd.w=scale(sd.w),rho.w=scale(rho.w),Db=scale(Db))

sampres.same<-data.frame(rhoN=getNtcor(sens.same), #scale predictors to standardize effect sizes
                       r=scale(r), Kb=scale(Kb), Kw=scale(Kw),rho.b=scale(rho.b),sd.b=scale(sd.b),
                       Db=scale(Db))

sampres.noow<-data.frame(rhoN=getNtcor(sens.noow), #scale predictors to standardize effect sizes
                       r=scale(r), Kb=scale(Kb), rho.b=scale(rho.b),sd.b=scale(sd.b),
                       sd.w=scale(sd.w),rho.w=scale(rho.w),Db=scale(Db))

lm.samp.main<-lm(rhoN~r+Kb+Kw+rho.b+rho.w+sd.b+sd.w+sd.b*rho.b+sd.w*rho.w+rho.b*rho.w+Kw*Kb+Db, data=sampres.main, na.action=na.exclude)
summary(lm.samp.main)

lm.samp.same<-lm(rhoN~r+Kb+Kw+rho.b+sd.b+sd.b*rho.b+Kw*Kb+Db, data=sampres.same, na.action=na.exclude)
summary(lm.samp.same)

lm.samp.noow<-lm(rhoN~r+Kb+rho.b+rho.w+sd.b+sd.w+sd.b*rho.b+sd.w*rho.w+rho.b*rho.w+Db, data=sampres.noow, na.action=na.exclude)
summary(lm.samp.noow)




# png("fig_parameffects_main_eN.png", units="in", res=300, 
#      width=6.5, height=3.25)
# par(mar=c(6,5,1,1))
# barplot(lm.samp.main$coefficients[-1], las=2, ylab = "Coefficient")
# #text(seq(from=0.6,by=1.2,length.out=length(lm.samp.rhoN$coefficients)-1),lm.samp.rhoN$coefficients[-1],paste0("p=",round(modsumm.add$coefficients[-1,4],2)),pos=3,offset=0.5)
# dev.off()
# 
# png("fig_parameffects_same_eN.png", units="in", res=300, 
#      width=6.5, height=3.25)
# par(mar=c(6,5,1,1))
# barplot(lm.samp.same$coefficients[-1], las=2, ylab = "Coefficient")
# #text(seq(from=0.6,by=1.2,length.out=length(lm.samp.rhoN$coefficients)-1),lm.samp.rhoN$coefficients[-1],paste0("p=",round(modsumm.add$coefficients[-1,4],2)),pos=3,offset=0.5)
# dev.off()
# 
# png("fig_parameffects_noow_eN.png", units="in", res=300, 
#      width=6.5, height=3.25)
# par(mar=c(6,5,1,1))
# barplot(lm.samp.noow$coefficients[-1], las=2, ylab = "Coefficient")
# #text(seq(from=0.6,by=1.2,length.out=length(lm.samp.rhoN$coefficients)-1),lm.samp.rhoN$coefficients[-1],paste0("p=",round(modsumm.add$coefficients[-1,4],2)),pos=3,offset=0.5)
# dev.off()


plotmat<-rbind(lm.samp.main$coefficients[-1],
               c(lm.samp.same$coefficients[-1][1:4],NA,lm.samp.same$coefficients[-1][5],NA,
                 lm.samp.same$coefficients[-1][6:7],NA,NA,lm.samp.same$coefficients[-1][8]),
               c(lm.samp.noow$coefficients[-1][1:2],NA,lm.samp.noow$coefficients[-1][3:10],NA))

semat<-rbind(summary(lm.samp.main)$coefficients[-1,2],
             c(summary(lm.samp.main)$coefficients[-1,2][1:4],NA,
               summary(lm.samp.main)$coefficients[-1,2][5],NA,
               summary(lm.samp.main)$coefficients[-1,2][6:7],NA,NA,
             summary(lm.samp.main)$coefficients[-1,2][8]),
             c(summary(lm.samp.main)$coefficients[-1,2][1:2],NA,
               summary(lm.samp.main)$coefficients[-1,2][3:10],NA)
)


plotnames<-c("r",
             expression(K[B]),
             expression(K[W]),
             expression(rho[B]),
             expression(rho[W]),
             expression(sigma[B]),
             expression(sigma[W]),
             "d",
             expression(paste(rho[B], sigma[B])),
             expression(paste(rho[W], sigma[W])),
             expression(paste(rho[B], rho[W])),
             expression(paste(K[B], K[W]))
             )
# save(modsumm.add, file="modsumm_main.RData")

png("fig2_simsens_eN.png", units="in", res=300, width=6.5, height=3.5)
par(mar=c(4,4,1,0.5))
b<-barplot(plotmat, las=2, ylab = "Effect size", beside=TRUE, names.arg=plotnames,
           ylim=c(-0.4,0.4),col=c("grey25","grey50","grey75"))
#abline(h=0)
text(x=c(11.5,18.5,26.5,38.5,42.5,47.5),y=0,labels="na",cex=0.5,adj=c(0.5,0))
arrows(x0=c(b), y0=c(plotmat)+1*c(semat), x1=c(b), y1=c(plotmat)-1*c(semat), length=0.02, 
       angle=90, code=3)
legend("topright",bty="n",pch=15,col=c("grey25","grey50","grey75"),
       legend=c("Main model","Same environment","No overwintering"))
dev.off()

```

Now, vary synchrony in breeding and overwintering environment while holding other parameters constant.
The main model is compared against two alternates: 
1) where population dynamics have breeding and overwintering seasons, but the environmental conditions are identical.
2) where population dynamics do not have distinct seasons but there are two environmental drivers.

```{r varrhos1, echo=FALSE, cache=TRUE}
library(parallel)
library(viridis)
source("~/GitHub/synchrony-seasonality/Fn_synchsim_mainmodel_eK.R")
source("~/GitHub/synchrony-seasonality/Fn_synchsim_altmodel_sameEnvironment_eK.R")
source("~/GitHub/synchrony-seasonality/Fn_synchsim_altmodel_noOverwintering_eK.R")

scentxt<-"r08Db0Kb10"

rho<-seq(0,1,by=0.05)
rho.b<-rep(expand.grid(rho,rho)[,1],each=500)
rho.w<-rep(expand.grid(rho,rho)[,2],each=500)
r=1.6
Kb=10
Kw=Kb
sd.b=1
sd.w=1
Db=0.0
Dw=0
nlocs=2
tmax=600
burn=100

ncores=detectCores()-2

cl<-makeCluster(ncores)
varrhos.main<-mcmapply(synchsim_main,r=r,Kb=Kb,Kw=Kw,rho.b=rho.b,rho.w=rho.w,
                        sd.b=sd.b,sd.w=sd.w,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)
varrhos.same<-mcmapply(synchsim_sameEnv,r=r,Kb=Kb, Kw=Kw, rho.b=rho.b,
                        sd.b=sd.b,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)
varrhos.noow<-mcmapply(synchsim_noOverwint,r=r,K=Kb,rho.b=rho.b,rho.w=rho.w,
                        sd.b=sd.b,sd.w=sd.w,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)

stopCluster(cl)


getNtcor<-function(inlist){ #extract synchrony in Nt
  out<-rep(NA, length(inlist))
  for(ii in 1:length(inlist)){
    tmp<-log(inlist[[ii]]$Nt[,-c(1:50)]+1)
    tmprho<-cor(t(tmp), use = "pairwise.complete.obs")
    out[ii]<-mean(tmprho[lower.tri(tmprho)], na.rm=T)
  }
  return(out)
}

getBtcor<-function(inlist){ #extract synchrony in Nt
  out<-rep(NA, length(inlist))
  for(ii in 1:length(inlist)){
    tmp<-log(inlist[[ii]]$Bt[,-c(1:50)]+1)
    tmprho<-cor(t(tmp), use = "pairwise.complete.obs")
    out[ii]<-mean(tmprho[lower.tri(tmprho)], na.rm=T)
  }
  return(out)
}

# getEl<-function(inlist){ #extract local extinction rate
#   out<-rep(NA, length(inlist))
#   for(ii in 1:length(inlist)){
#     tmp<-inlist[[ii]]$Nt[,-c(1:50)]
#     out[ii]<-sum(tmp==0,na.rm=T)/sum(!is.na(tmp))
#   }
#   return(out)
# }

# getEg<-function(inlist){ #extract global extinction rate
#   out<-rep(NA, length(inlist))
#   for(ii in 1:length(inlist)){
#     tmp<-inlist[[ii]]$Nt[,-c(1:burn)]
#     if(all(is.na(tmp))){out[ii]<-NA}
#     else if(!any(is.na(tmp[,ncol(tmp)]))){out[ii]<-0}
#     else{out[ii]<-1/(max(rowSums(!is.na(tmp)))*2)}
#   }
#   return(out)
# }

getCV<-function(inlist){ #extract CV of spatial total Nt
  out<-rep(NA, length(inlist))
  for(ii in 1:length(inlist)){
    tmp<-inlist[[ii]]$Nt[,-c(1:burn)]
    if(all(is.na(tmp))){out[ii]<-NA}
    else{out[ii]<-sd(colSums(tmp))/mean(colSums(tmp))}
  }
  return(out)
}

Ntcor.main<-data.frame(rho.b=rho.b, rho.w=rho.w, Ntcor=getNtcor(varrhos.main))
Ntcor.main<-aggregate(Ntcor.main, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
Ntcor.main<-matrix(Ntcor.main$Ntcor, nrow=length(rho), ncol=length(rho))

Btcor.main<-data.frame(rho.b=rho.b, rho.w=rho.w, Btcor=getBtcor(varrhos.main))
Btcor.main<-aggregate(Btcor.main, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
Btcor.main<-matrix(Btcor.main$Btcor, nrow=length(rho), ncol=length(rho))

CV.main<-data.frame(rho.b=rho.b, rho.w=rho.w, CV=getCV(varrhos.main))
CV.main<-aggregate(CV.main, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
CV.main<-matrix(CV.main$CV, nrow=length(rho), ncol=length(rho))


Ntcor.same<-data.frame(rho.b=rho.b, Ntcor=getNtcor(varrhos.same))
Ntcor.same<-aggregate(Ntcor ~ rho.b, data = Ntcor.same, FUN=mean, na.rm=T)

Btcor.same<-data.frame(rho.b=rho.b, Btcor=getBtcor(varrhos.same))
Btcor.same<-aggregate(Btcor ~ rho.b, data = Btcor.same, FUN=mean, na.rm=T)

CV.same<-data.frame(rho.b=rho.b, CV=getCV(varrhos.same))
CV.same<-aggregate(CV ~ rho.b, data = CV.same, FUN=mean, na.rm=T)


Ntcor.noow<-data.frame(rho.b=rho.b, rho.w=rho.w, Ntcor=getNtcor(varrhos.noow))
Ntcor.noow<-aggregate(Ntcor.noow, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
Ntcor.noow<-matrix(Ntcor.noow$Ntcor, nrow=length(rho), ncol=length(rho))

Btcor.noow<-data.frame(rho.b=rho.b, rho.w=rho.w, Btcor=getBtcor(varrhos.noow))
Btcor.noow<-aggregate(Btcor.noow, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
Btcor.noow<-matrix(Btcor.noow$Btcor, nrow=length(rho), ncol=length(rho))

CV.noow<-data.frame(rho.b=rho.b, rho.w=rho.w, CV=getCV(varrhos.noow))
CV.noow<-aggregate(CV.noow, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
CV.noow<-matrix(CV.noow$CV, nrow=length(rho), ncol=length(rho))


# get difference matrices

diff.NtBtcor.main<-Btcor.main-Ntcor.main
diff.NtBtcor.same<-Btcor.same-Ntcor.same
diff.NtBtcor.noow<-Ntcor.noow-Btcor.noow

#diff1.Ntcor <- Ntcor.main-Ntcor.same
#diff1.Eg <- Eg.main-Eg.same

#diff2.Ntcor <- Ntcor.main-Ntcor.noow
#diff2.Eg <- Eg.main-Eg.noow



pal<-colorRampPalette(colors=c("red","white","blue"))


## Make figure comparing syncrhony in different seasons

png(paste0("~/GitHub/synchrony-seasonality/figSX_compare_seasons_eK.png"), units="in", res=300, width=6.5, height=2.42)

par(mfrow=c(1,3), mar=c(1.8,1.8,0.5,0), mgp=c(2.7,0.5,0), tcl=-0.3, oma=c(1.1,1.1,1.1,1))
#main model
image(rho, rho, Ntcor.main, xlab="", ylab="", asp=1, main="",
      col=pal(50), zlim=c(-1,1))
tmpdf<-data.frame(z=c(Ntcor.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
text(0.05,0.95,"a)")

image(rho, rho, Btcor.main, xlab="", ylab="", asp=1, main="",
      col=pal(50), zlim=c(-1,1))
tmpdf<-data.frame(z=c(Btcor.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
text(0.05,0.95,"b)")

image(rho, rho, diff.NtBtcor.main, xlab="", ylab="", asp=1, main="",
      col=pal(50), zlim=c(-.7,.7))
tmpdf<-data.frame(z=c(diff.NtBtcor.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
text(0.05,0.95,"c)")

mtext("Spatial synchrony of breeding season environment",1,outer=T,cex=0.8)
mtext("Overwintering synchrony",2,outer=T,cex=0.8, line=0)
#mtext("Main model", 2, outer=T, at=3/4, cex=0.8, line=0)
#mtext("Alt: same environment", 2, outer=T, at=1/4, cex=0.8, line=0)
mtext("cor(Nt)", outer=T, at=1/6, cex=0.8, line=-0.25)
mtext("cor(Bt)", outer=T, at=3/6, cex=0.8, line=-0.25)
mtext("cor(Bt)-cor(Nt)", outer=T, at=5/6, cex=0.8, line=-0.25)


dev.off()



#make figure comparing main model to alternate

png("~/GitHub/synchrony-seasonality/figSX_compare_alternates_eK.png", units="in", res=300, width=6.5, height=4.65)

par(mfcol=c(2,3), mar=c(2,3,2.5,1), oma=c(1.5,0,0,0),mgp=c(2,0.6,0), tcl=-0.4)
#main model
image(rho, rho, Ntcor.main, xlab="", ylab="Winter environment synchrony", asp=1, 
      main="", col=pal(50), zlim=c(-1,1))
tmpdf<-data.frame(z=c(Ntcor.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
mtext("Main model",3,line=0.1,cex=0.7)
text(0.05,0.95,"a)")

image(rho, rho, CV.main, xlab="", ylab="Winter environment synchrony", asp=1, 
      main="",
      col=viridis(50))
tmpdf<-data.frame(z=c(CV.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
mtext("Main model",3,line=0.1, cex=0.7)
text(0.05,0.95,"g)")


plot(Ntcor.same$rho.b, Ntcor.same$Ntcor, pch=19, xlab="", ylab="Population synchrony")
mtext("Alt: same environment",3,line=0.1,cex=0.7)
mtext("Population spatial synchrony",3,line=1.1,cex=0.9)
text(0.05,0.95,"b)")

plot(CV.same$rho.b, CV.same$CV, pch=19, xlab="", ylab="Metapopulation CV")
mtext("Alt: same environment",3,line=0.1,cex=0.7)
mtext("Metapopulation CV",3,line=1.1,cex=0.9)
text(0.05,0.135,"h)")


#difference - no overwintering
image(rho, rho, Ntcor.noow, xlab="", ylab="Winter environment synchrony", asp=1, main="",
      col=pal(50), zlim=c(-1,1))
tmpdf<-data.frame(z=c(Ntcor.noow), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
mtext("Alt: no overwintering",3,line=0.1,cex=0.7)
text(0.05,0.95,"c)")

image(rho, rho, CV.noow, xlab="", ylab="Winter environment synchrony", asp=1, main="",
      col=viridis(50))
tmpdf<-data.frame(z=c(CV.noow), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
mtext("Alt: no overwintering",3,line=0.1,cex=0.7)
text(0.05,0.95,"i)")

mtext("Spatial synchrony of breeding season environment",1,outer=T,cex=0.9)
#mtext("Spatial synchrony of overwintering season environment",2,outer=T,cex=0.9)

dev.off()

```
It looks like synchrony is very sensitive to how environmental noises are applied, 
e.g. are they on intrinsic growth rate, carrying capacity, or abundance?
So, let's play with this.
First, examining the case where breeding season noise is on r and overwintering season noise is on K.
For the alternate model with no overwintering, there is one noise on r and one on K.

```{r varrhos2, echo=FALSE, cache=TRUE}
library(parallel)
library(viridis)
source("~/GitHub/synchrony-seasonality/Fn_synchsim_mainmodel_ereK.R")
source("~/GitHub/synchrony-seasonality/Fn_synchsim_altmodel_sameEnvironment_ereK.R")
source("~/GitHub/synchrony-seasonality/Fn_synchsim_altmodel_noOverwintering_ereK.R")


rho<-seq(0,1,by=0.05)
rho.b<-rep(expand.grid(rho,rho)[,1],each=500)
rho.w<-rep(expand.grid(rho,rho)[,2],each=500)
r=1.6
Kb=10
Kw=Kb
sd.b=0.5
sd.w=1
Db=0.0
Dw=0
nlocs=2
tmax=600
burn=100

ncores=detectCores()-2

cl<-makeCluster(ncores)
varrhos.main<-mcmapply(synchsim_main,r=r,Kb=Kb,Kw=Kw,rho.b=rho.b,rho.w=rho.w,
                        sd.b=sd.b,sd.w=sd.w,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)
varrhos.same<-mcmapply(synchsim_sameEnv,r=r,Kb=Kb, Kw=Kw, rho.b=rho.b,
                        sd.b=sd.b,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)
varrhos.noow<-mcmapply(synchsim_noOverwint,r=r,K=Kb,rho.b=rho.b,rho.w=rho.w,
                        sd.b=sd.b,sd.w=sd.w,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)

stopCluster(cl)


getNtcor<-function(inlist){ #extract synchrony in Nt
  out<-rep(NA, length(inlist))
  for(ii in 1:length(inlist)){
    tmp<-log(inlist[[ii]]$Nt[,-c(1:50)]+1)
    tmprho<-cor(t(tmp), use = "pairwise.complete.obs")
    out[ii]<-mean(tmprho[lower.tri(tmprho)], na.rm=T)
  }
  return(out)
}

getBtcor<-function(inlist){ #extract synchrony in Nt
  out<-rep(NA, length(inlist))
  for(ii in 1:length(inlist)){
    tmp<-log(inlist[[ii]]$Bt[,-c(1:50)]+1)
    tmprho<-cor(t(tmp), use = "pairwise.complete.obs")
    out[ii]<-mean(tmprho[lower.tri(tmprho)], na.rm=T)
  }
  return(out)
}

getCV<-function(inlist){ #extract CV of spatial total Nt
  out<-rep(NA, length(inlist))
  for(ii in 1:length(inlist)){
    tmp<-inlist[[ii]]$Nt[,-c(1:burn)]
    if(all(is.na(tmp))){out[ii]<-NA}
    else{out[ii]<-sd(colSums(tmp))/mean(colSums(tmp))}
  }
  return(out)
}

Ntcor.main<-data.frame(rho.b=rho.b, rho.w=rho.w, Ntcor=getNtcor(varrhos.main))
Ntcor.main<-aggregate(Ntcor.main, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
Ntcor.main<-matrix(Ntcor.main$Ntcor, nrow=length(rho), ncol=length(rho))

Btcor.main<-data.frame(rho.b=rho.b, rho.w=rho.w, Btcor=getBtcor(varrhos.main))
Btcor.main<-aggregate(Btcor.main, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
Btcor.main<-matrix(Btcor.main$Btcor, nrow=length(rho), ncol=length(rho))

CV.main<-data.frame(rho.b=rho.b, rho.w=rho.w, CV=getCV(varrhos.main))
CV.main<-aggregate(CV.main, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
CV.main<-matrix(CV.main$CV, nrow=length(rho), ncol=length(rho))


Ntcor.same<-data.frame(rho.b=rho.b, Ntcor=getNtcor(varrhos.same))
Ntcor.same<-aggregate(Ntcor ~ rho.b, data = Ntcor.same, FUN=mean, na.rm=T)

Btcor.same<-data.frame(rho.b=rho.b, Btcor=getBtcor(varrhos.same))
Btcor.same<-aggregate(Btcor ~ rho.b, data = Btcor.same, FUN=mean, na.rm=T)

CV.same<-data.frame(rho.b=rho.b, CV=getCV(varrhos.same))
CV.same<-aggregate(CV ~ rho.b, data = CV.same, FUN=mean, na.rm=T)


Ntcor.noow<-data.frame(rho.b=rho.b, rho.w=rho.w, Ntcor=getNtcor(varrhos.noow))
Ntcor.noow<-aggregate(Ntcor.noow, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
Ntcor.noow<-matrix(Ntcor.noow$Ntcor, nrow=length(rho), ncol=length(rho))

Btcor.noow<-data.frame(rho.b=rho.b, rho.w=rho.w, Btcor=getBtcor(varrhos.noow))
Btcor.noow<-aggregate(Btcor.noow, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
Btcor.noow<-matrix(Btcor.noow$Btcor, nrow=length(rho), ncol=length(rho))

CV.noow<-data.frame(rho.b=rho.b, rho.w=rho.w, CV=getCV(varrhos.noow))
CV.noow<-aggregate(CV.noow, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
CV.noow<-matrix(CV.noow$CV, nrow=length(rho), ncol=length(rho))


# get difference matrices

diff.NtBtcor.main<-Btcor.main-Ntcor.main
diff.NtBtcor.noow<-Ntcor.noow-Btcor.noow



pal<-colorRampPalette(colors=c("red","white","blue"))


## Make figure comparing syncrhony in different seasons

png(paste0("~/GitHub/synchrony-seasonality/figSX_compare_seasons_ereK.png"), units="in", res=300, width=6.5, height=2.42)

par(mfrow=c(1,3), mar=c(1.8,1.8,0.5,0), mgp=c(2.7,0.5,0), tcl=-0.3, oma=c(1.1,1.1,1.1,1))
#main model
image(rho, rho, Ntcor.main, xlab="", ylab="", asp=1, main="",
      col=pal(50), zlim=c(-1,1))
tmpdf<-data.frame(z=c(Ntcor.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
text(0.05,0.95,"a)")

image(rho, rho, Btcor.main, xlab="", ylab="", asp=1, main="",
      col=pal(50), zlim=c(-1,1))
tmpdf<-data.frame(z=c(Btcor.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
text(0.05,0.95,"b)")

image(rho, rho, diff.NtBtcor.main, xlab="", ylab="", asp=1, main="",
      col=pal(50), zlim=c(-.7,.7))
tmpdf<-data.frame(z=c(diff.NtBtcor.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
text(0.05,0.95,"c)")

mtext("Spatial synchrony of breeding season environment",1,outer=T,cex=0.8)
mtext("Overwintering synchrony",2,outer=T,cex=0.8, line=0)
#mtext("Main model", 2, outer=T, at=3/4, cex=0.8, line=0)
#mtext("Alt: same environment", 2, outer=T, at=1/4, cex=0.8, line=0)
mtext("cor(Nt)", outer=T, at=1/6, cex=0.8, line=-0.25)
mtext("cor(Bt)", outer=T, at=3/6, cex=0.8, line=-0.25)
mtext("cor(Bt)-cor(Nt)", outer=T, at=5/6, cex=0.8, line=-0.25)


dev.off()



#make figure comparing main model to alternate

png("~/GitHub/synchrony-seasonality/figSX_compare_alternates_ereK.png", units="in", res=300, width=6.5, height=4.65)

par(mfcol=c(2,3), mar=c(2,3,2.5,1), oma=c(1.5,0,0,0),mgp=c(2,0.6,0), tcl=-0.4)
#main model
image(rho, rho, Ntcor.main, xlab="", ylab="Winter environment synchrony", asp=1, 
      main="", col=pal(50), zlim=c(-1,1))
tmpdf<-data.frame(z=c(Ntcor.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
mtext("Main model",3,line=0.1,cex=0.7)
text(0.05,0.95,"a)")

image(rho, rho, CV.main, xlab="", ylab="Winter environment synchrony", asp=1, 
      main="",
      col=viridis(50))
tmpdf<-data.frame(z=c(CV.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
mtext("Main model",3,line=0.1, cex=0.7)
text(0.05,0.95,"g)")


plot(Ntcor.same$rho.b, Ntcor.same$Ntcor, pch=19, xlab="", ylab="Population synchrony")
mtext("Alt: same environment",3,line=0.1,cex=0.7)
mtext("Population spatial synchrony",3,line=1.1,cex=0.9)
text(0.05,0.997,"b)")

plot(CV.same$rho.b, CV.same$CV, pch=19, xlab="", ylab="Metapopulation CV")
mtext("Alt: same environment",3,line=0.1,cex=0.7)
mtext("Metapopulation CV",3,line=1.1,cex=0.9)
text(0.05,0.0944,"h)")


#difference - no overwintering
image(rho, rho, Ntcor.noow, xlab="", ylab="Winter environment synchrony", asp=1, main="",
      col=pal(50), zlim=c(-1,1))
tmpdf<-data.frame(z=c(Ntcor.noow), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
mtext("Alt: no overwintering",3,line=0.1,cex=0.7)
text(0.05,0.95,"c)")

image(rho, rho, CV.noow, xlab="", ylab="Winter environment synchrony", asp=1, main="",
      col=viridis(50))
tmpdf<-data.frame(z=c(CV.noow), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
mtext("Alt: no overwintering",3,line=0.1,cex=0.7)
text(0.05,0.95,"i)")

mtext("Spatial synchrony of breeding season environment",1,outer=T,cex=0.9)
#mtext("Spatial synchrony of overwintering season environment",2,outer=T,cex=0.9)

dev.off()

```
Now, let's look at the case where the environmental noises affect N additively, after population processes.

```{r varrhos3, echo=FALSE, cache=TRUE}
library(parallel)
library(viridis)
source("~/GitHub/synchrony-seasonality/Fn_synchsim_mainmodel_eN.R")
source("~/GitHub/synchrony-seasonality/Fn_synchsim_altmodel_sameEnvironment_eN.R")
source("~/GitHub/synchrony-seasonality/Fn_synchsim_altmodel_noOverwintering_eN.R")

scentxt<-"r08Db0Kb10"

rho<-seq(0,1,by=0.05)
rho.b<-rep(expand.grid(rho,rho)[,1],each=500)
rho.w<-rep(expand.grid(rho,rho)[,2],each=500)
r=1.6
Kb=10
Kw=Kb
sd.b=1
sd.w=1
Db=0.0
Dw=0
nlocs=2
tmax=600
burn=100

ncores=detectCores()-2

cl<-makeCluster(ncores)
varrhos.main<-mcmapply(synchsim_main,r=r,Kb=Kb,Kw=Kw,rho.b=rho.b,rho.w=rho.w,
                        sd.b=sd.b,sd.w=sd.w,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)
varrhos.same<-mcmapply(synchsim_sameEnv,r=r,Kb=Kb, Kw=Kw, rho.b=rho.b,
                        sd.b=sd.b,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)
varrhos.noow<-mcmapply(synchsim_noOverwint,r=r,K=Kb,rho.b=rho.b,rho.w=rho.w,
                        sd.b=sd.b,sd.w=sd.w,Db=Db,tmax=tmax,nlocs=nlocs, SIMPLIFY = F)

stopCluster(cl)


getNtcor<-function(inlist){ #extract synchrony in Nt
  out<-rep(NA, length(inlist))
  for(ii in 1:length(inlist)){
    tmp<-log(inlist[[ii]]$Nt[,-c(1:50)]+1)
    tmprho<-cor(t(tmp), use = "pairwise.complete.obs")
    out[ii]<-mean(tmprho[lower.tri(tmprho)], na.rm=T)
  }
  return(out)
}

getBtcor<-function(inlist){ #extract synchrony in Nt
  out<-rep(NA, length(inlist))
  for(ii in 1:length(inlist)){
    tmp<-log(inlist[[ii]]$Bt[,-c(1:50)]+1)
    tmprho<-cor(t(tmp), use = "pairwise.complete.obs")
    out[ii]<-mean(tmprho[lower.tri(tmprho)], na.rm=T)
  }
  return(out)
}

getCV<-function(inlist){ #extract CV of spatial total Nt
  out<-rep(NA, length(inlist))
  for(ii in 1:length(inlist)){
    tmp<-inlist[[ii]]$Nt[,-c(1:burn)]
    if(all(is.na(tmp))){out[ii]<-NA}
    else{out[ii]<-sd(colSums(tmp))/mean(colSums(tmp))}
  }
  return(out)
}

Ntcor.main<-data.frame(rho.b=rho.b, rho.w=rho.w, Ntcor=getNtcor(varrhos.main))
Ntcor.main<-aggregate(Ntcor.main, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
Ntcor.main<-matrix(Ntcor.main$Ntcor, nrow=length(rho), ncol=length(rho))

Btcor.main<-data.frame(rho.b=rho.b, rho.w=rho.w, Btcor=getBtcor(varrhos.main))
Btcor.main<-aggregate(Btcor.main, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
Btcor.main<-matrix(Btcor.main$Btcor, nrow=length(rho), ncol=length(rho))

CV.main<-data.frame(rho.b=rho.b, rho.w=rho.w, CV=getCV(varrhos.main))
CV.main<-aggregate(CV.main, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
CV.main<-matrix(CV.main$CV, nrow=length(rho), ncol=length(rho))


Ntcor.same<-data.frame(rho.b=rho.b, Ntcor=getNtcor(varrhos.same))
Ntcor.same<-aggregate(Ntcor ~ rho.b, data = Ntcor.same, FUN=mean, na.rm=T)

Btcor.same<-data.frame(rho.b=rho.b, Btcor=getBtcor(varrhos.same))
Btcor.same<-aggregate(Btcor ~ rho.b, data = Btcor.same, FUN=mean, na.rm=T)

CV.same<-data.frame(rho.b=rho.b, CV=getCV(varrhos.same))
CV.same<-aggregate(CV ~ rho.b, data = CV.same, FUN=mean, na.rm=T)


Ntcor.noow<-data.frame(rho.b=rho.b, rho.w=rho.w, Ntcor=getNtcor(varrhos.noow))
Ntcor.noow<-aggregate(Ntcor.noow, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
Ntcor.noow<-matrix(Ntcor.noow$Ntcor, nrow=length(rho), ncol=length(rho))

Btcor.noow<-data.frame(rho.b=rho.b, rho.w=rho.w, Btcor=getBtcor(varrhos.noow))
Btcor.noow<-aggregate(Btcor.noow, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
Btcor.noow<-matrix(Btcor.noow$Btcor, nrow=length(rho), ncol=length(rho))

CV.noow<-data.frame(rho.b=rho.b, rho.w=rho.w, CV=getCV(varrhos.noow))
CV.noow<-aggregate(CV.noow, by=list(rho.b, rho.w), FUN=mean, na.rm=T)
CV.noow<-matrix(CV.noow$CV, nrow=length(rho), ncol=length(rho))


# get difference matrices

diff.NtBtcor.main<-Btcor.main-Ntcor.main
diff.NtBtcor.noow<-Ntcor.noow-Btcor.noow



pal<-colorRampPalette(colors=c("red","white","blue"))


## Make figure comparing syncrhony in different seasons

png(paste0("~/GitHub/synchrony-seasonality/fig3_compare_seasons_eN.png"), units="in", res=300, width=6.5, height=2.42)

par(mfrow=c(1,3), mar=c(1.8,1.8,0.5,0), mgp=c(2.7,0.5,0), tcl=-0.3, oma=c(1.1,1.1,1.1,1))
#main model
image(rho, rho, Ntcor.main, xlab="", ylab="", asp=1, main="",
      col=pal(50), zlim=c(-1,1))
tmpdf<-data.frame(z=c(Ntcor.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
text(0.05,0.95,"a)")

image(rho, rho, Btcor.main, xlab="", ylab="", asp=1, main="",
      col=pal(50), zlim=c(-1,1))
tmpdf<-data.frame(z=c(Btcor.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
text(0.05,0.95,"b)")

image(rho, rho, diff.NtBtcor.main, xlab="", ylab="", asp=1, main="",
      col=pal(50), zlim=c(-.7,.7))
tmpdf<-data.frame(z=c(diff.NtBtcor.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
text(0.05,0.95,"c)")

mtext("Spatial synchrony of breeding season environment",1,outer=T,cex=0.8)
mtext("Overwintering synchrony",2,outer=T,cex=0.8, line=0)
#mtext("Main model", 2, outer=T, at=3/4, cex=0.8, line=0)
#mtext("Alt: same environment", 2, outer=T, at=1/4, cex=0.8, line=0)
mtext("cor(Nt)", outer=T, at=1/6, cex=0.8, line=-0.25)
mtext("cor(Bt)", outer=T, at=3/6, cex=0.8, line=-0.25)
mtext("cor(Bt)-cor(Nt)", outer=T, at=5/6, cex=0.8, line=-0.25)

dev.off()


## supplement figure with alternate models

# #same environment
# plot(Ntcor.same$rho.b, Ntcor.same$Ntcor, pch=16)
# # image(rho, rho, Ntcor.same, xlab="", ylab="", asp=1, main="",
# #       col=pal(50), zlim=c(-1,1))
# # tmpdf<-data.frame(z=c(Ntcor.same), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
# # sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
# # contour(rho, rho, sm, add=T)
# text(0.05,0.95,"d)")
# 
# plot(Btcor.same$rho.b, Btcor.same$Btcor, pch=16)
# text(0.05,0.95,"e)")
# 
# plot(Ntcor.same$rho.b, Btcor.same$Btcor - Ntcor.same$Ntcor, pch=16)
# text(0.05,0.95,"f)")


#make figure comparing main model to alternate

png("~/GitHub/synchrony-seasonality/fig4_compare_alternates_eN.png", units="in", res=300, width=6.5, height=4.65)

par(mfcol=c(2,3), mar=c(2,3,2.5,1), oma=c(1.5,0,0,0),mgp=c(2,0.6,0), tcl=-0.4)
#main model
image(rho, rho, Ntcor.main, xlab="", ylab="Winter environment synchrony", asp=1, 
      main="", col=pal(50), zlim=c(-1,1))
tmpdf<-data.frame(z=c(Ntcor.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
mtext("Main model",3,line=0.1,cex=0.7)
text(0.05,0.95,"a)")

image(rho, rho, CV.main, xlab="", ylab="Winter environment synchrony", asp=1, 
      main="",
      col=viridis(50))
tmpdf<-data.frame(z=c(CV.main), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
mtext("Main model",3,line=0.1, cex=0.7)
text(0.05,0.95,"g)")


plot(Ntcor.same$rho.b, Ntcor.same$Ntcor, pch=19, xlab="", ylab="Population synchrony")
mtext("Alt: same environment",3,line=0.1,cex=0.7)
mtext("Population spatial synchrony",3,line=1.1,cex=0.9)
text(0.05,0.997,"b)")

plot(CV.same$rho.b, CV.same$CV, pch=19, xlab="", ylab="Metapopulation CV")
mtext("Alt: same environment",3,line=0.1,cex=0.7)
mtext("Metapopulation CV",3,line=1.1,cex=0.9)
text(0.05,0.0944,"h)")


#difference - no overwintering
image(rho, rho, Ntcor.noow, xlab="", ylab="Winter environment synchrony", asp=1, main="",
      col=pal(50), zlim=c(-1,1))
tmpdf<-data.frame(z=c(Ntcor.noow), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
mtext("Alt: no overwintering",3,line=0.1,cex=0.7)
text(0.05,0.95,"c)")

image(rho, rho, CV.noow, xlab="", ylab="Winter environment synchrony", asp=1, main="",
      col=viridis(50))
tmpdf<-data.frame(z=c(CV.noow), x=expand.grid(rho,rho)[,1], y=expand.grid(rho,rho)[,2])
sm<-matrix(predict(loess(z~x+y, data=tmpdf, span=0.1)),length(rho),length(rho))
contour(rho, rho, sm, add=T)
mtext("Alt: no overwintering",3,line=0.1,cex=0.7)
text(0.05,0.95,"i)")

mtext("Spatial synchrony of breeding season environment",1,outer=T,cex=0.9)
#mtext("Spatial synchrony of overwintering season environment",2,outer=T,cex=0.9)

dev.off()

```
